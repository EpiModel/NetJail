---
title: "FCJ Cell Level Network Analysis"
author: "Karina Wallrafen-Sam"
date: "3/24/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Step 0: Load in data and conduct initial processing/cleaning

We start by loading all excel files from the data/input/FJC folder into a single large data frame, `all_data`. Although some of the excel files include their data split into multiple sheets (one for each floor/tower), all of them start with the full roster in a single sheet, so we disregard the extra sheets.

When we check for the uniqueness of the SO Numbers, we see that 6 SO Numbers are associated with multiple DOBs and 1 with multiple Races. For these SO Numbers, we consider the DOB/Race from the most recent roster to be the 'truth'. Also, SO Number P01007978 has Gender = “M” from 10/27/2021 to 01/31/2022 and Gender = “F” on 02/04/2022. Since this person is always located in parts of the jail that house male residents, we will consider Gender = "M" to be the 'truth'. We adjust the data accordingly for these 8 residents. 

For now, we subset out all data rows that contain female residents and/or locations that do not follow the Floor + Tower + Block + Cell pattern. (This data is placed into two data frames, `data_f` and `m_specialLoc`, which we ignore for now but will need to add back in eventually.) We proceed only with data rows that contain male residents and 'standard' locations, which we put into a smaller data frame called `m_stdLoc`. About 500 SO Numbers in `m_stdLoc` also appear in `m_specialLoc`. (For example, many residents spend one day in Intake, a 'special' location, before going to a standard cell). Since we are ignoring `m_specialLoc` for now, any results regarding turnover rates, durations of stay, etc. should be taken with a grain of salt. 

At the end of this step, we have two data frames that we will use going forward: `m_stdLoc` and `ids`. `ids` lists out the 4589 residents who ever appear in `m_stdLoc` and assigns them each an `id` between 1 and 4589. There's a one-to-one mapping from SO Number to `id`, making them interchangeable, but we will use `id` from now on for simplicity. 

```{r, child = 'Sections/Step0-InitialProcessing.Rmd', include = FALSE}
```

## Step 1: Create an edge list of cell-level edges

We create `dates`, which assigns two numerical values to each date for which we have data: `DayIndex` and `DayNum`. `DayIndex` is basically the roster number and `DayNum` tells us how many days have passed since October 27th, 2021 -- the first day for which we have data. For example, for December 1st, 2021, `DayIndex` is 2 (since this is our second roster) and `DayNum` is 36.

In order to list out all cell-level edges, we start by merging `cDailyLoc` (which is basically `m_stdLoc` but with the columns reorganized) with itself and only keep rows where `id.x` is less than `id.y`. This gives us a list of pairs of residents who were ever in the same cell on the same day. We then create a counter that increments every time (a) the pairing changes, (b) there's a time gap, OR (c) the location changes. (a) is self-explanatory. (b) means that if Person A and Person B were in a cell together in Roster 1, NOT in a cell together in Roster 2, and in a cell together again in Roster 3 (on 12/08), then we create one edge between A and B that is present on Day 1 (10/27) and gone on Day 2 (10/28) and another that forms on Day 43 (12/08). (c) means that if Person A and Person B were in Cell 1 together in Roster 1 (on 10/27) and in Cell 2 together in Roster 2 (on 12/01), we create one edge between A and B that is present on Day 1 (10/27) and gone on Day 2 (10/28) and another that forms on Day 36 (12/01). 

Once we have this counter, creating the edge list is straightforward: we group on the counter and list out the id for the head, the id for the tail, the day number on which the edge is first present, and the day number on which the edge is last present. We also note if edges are left-censored and/or right-censored. This information is stored in `cEdges`. 

```{r, child = 'Sections/Step1-EdgeList.Rmd', include = FALSE}
```

## Step 2: Identify when nodes are active and in known locations

We create one data frame, `cLocs`, that lists out timeframes when we know (or believe) a particular person was in a particular location, and another, `activeDays`, that lists out timeframes when we know (or believe) a particular person was in the jail (in a standard location) at all. Our general approach is that if something is the same in two consecutive rosters, then we assume it was also the same in the time between the two rosters.

For example, say that Person A is in Cell 1 in Roster 1 (on 10/27, or Day 1) and is still in Cell 1 in Roster 2 (on 12/01, or Day 36). Then we assume Person A was (a) 'active' (i.e., in the jail) and (b) located in Cell 1 the whole time between Day 1 and Day 36, too. If Person A is in Cell 1 in Roster 1 (on 10/27, or Day 1) and is in Cell 2 in Roster 2 (on 12/01, or Day 36), then we assume that Person A was also 'active' on Days 2 - 35 but we do not assume anything about their particular location during the jail during that time.

For a real example, consider SO Number P00069424 (node 10). This person is in Roster 1 (on 10/27, or Day 1), Roster 2 (on 12/01, or Day 36), Roster 22 on (1/21, or Day 87), Roster 23 on (1/26, or Day 92), Roster 24 (on 1/31, or Day 97), and Roster 25 (on 02/04, or Day 101). They are in 3N518 in Rosters 1 and 2, then in 2S200 in Roster 22, in 2S210 for Roster 23, in 4N200 for Roster 24, and in 4N212 for Roster 25. 

We thus consider them 'active' until Day 36 (inclusive) and from Day 87 on. We consider them to be 'in' 3N518 until Day 36 (inclusive), 'in' 2S200 on Day 87 only, 'in' 2S210 on Day 92 only, 'in' 4N200 on Day 97 only, and 'in' 4N212 for Day 101 only. This means that on Day 90, for example, node 10 is active but does not have an active location. 

```{r, child = 'Sections/Step2-ActiveSpells.Rmd', include = FALSE}
```

## Step 3: Create a dynamic network object

In order to create a `networkDynamic` object, we first need to manipulate `cEdges` a bit. We replace the column `lastTime` (the last day on which the edge is present) with `terminus` (the day *after* last day on which the edge is present, which is the day on which the edge should dissolve) and change the column name `startTime` to `onset` for consistency (it's the same column, though). We also change the `onset` value to `-Inf` for left-censored edges and the `terminus` value to `Inf` for right-censored edges (this is probably unnecessary).

We then need to create a static network that's the same size as the dynamic network we're going to create. This is very annoying because it makes the code much slower for some reason, but it seems to be the only way to specify that our network is not directed, which is important. 

Then we're ready to create our `networkDynamic` object. We use the `cLocs` data frame we created in Step 2 to create a dynamic (TEA) node attribute called `location`. We also set age, race, and gender as (static) vertex attributes. (Each person's age is calculated as of the first day that they appear in the data. Some of the residents do have a birthday during the October - February period we're considering, but we ignore that.) Finally, we activate nodes based on the data in `activeDays`. 

```{r, child = 'Sections/Step3-DynNWObject.Rmd', include = FALSE}
```

## Step 4: Calculate overall degree distribution

To calculate the degree distribution over time, we extract the network at each time point for which we have a roster (Day 1, Day 36, etc.) and use the `degreedist()` function on the extracted networks. We plot the degree distribution at 6 selected time points (as close to the beginning and middle of each month as possible.) We also calculate the mean degree at each time point for which we have a roster and display these values in both a box plot and a scatter plot. In the box plot, each 'box' spans from the mean minus one standard deviation to the mean plus one standard deviation at that time point (with the lines spanning from minimum to maximum at each time point). Since the degree distributions are so right-skewed, the mean minus one standard deviation is often less than 0 (although of course no node has a degree less than 0).

`cOverallMeanDeg` is a simple, un-weighted average of these 25 mean degree values (each day is weighted equally, without regard for changing network size.) `cSubsetMeanDeg`, similarly, is a simple, un-weighted average of the 11 mean degree values from January 11th to January 21st. 

```{r, child = 'Sections/Step4-DegreeDist.Rmd', echo = FALSE, message = FALSE, warning = FALSE}
```

## Step 5: Calculate degree distribution by attribute

In Step 5, we perform the same operations as in Step 4, but broken down by race (a fixed attribute), age (which we are treating as a fixed attribute), and floor (a time-varying attribute, which we extract at each time point for which we have a roster). We break age into 10-year age categories and divide race into Black, White, and Other.

```{r, child = 'Sections/Step5-DegreeDistByAttr.Rmd', results = 'asis', echo = FALSE, message = FALSE, warning = FALSE}
```

## Step 6: TO DO
Turnover rates within cells using daily data 
Turnover rates within cells using all data
Turnover rates within cells by attribute using daily data 
Turnover rates within cells by attribute using all data

```{r, child = 'Sections/Step6-CellTurnover.Rmd', echo = FALSE, message = FALSE, warning = FALSE}
```

## Step 7: Estimate Turnover Rates

In this section, we calculate turnover rates (into and out of the jail) overall and by attribute, for the whole dataset (Oct 27th - Feb 4th) and for the daily subset (Jan 11th - Jan 21st). We attempt adapt the DOJ's definition of "weekly turnover rate" ("The sum of weekly admissions and releases divided by the average daily population") since we do not have consistent weekly data. Instead, we calculate the following:

(1) For the whole dataset, we add up the known admissions (i.e., the number of spells of activity, as defined in Step 2, that are not left-censored) and the known releases (i.e., the number of spells of activity, as defined in Step 2, that are not right-censored). These numbers include repeat admissions and releases. We calculate `TurnoverIn` by dividing the number of admissions by the average active network size (i.e., the average number of residents in the jail across the 25 days for which we have data). Similarly, we calculate `TurnoverOut` by dividing the number of releases by the average active network size. Note that the numerators are probably significantly underestimated (for example, anyone admitted and released during the month of November is not counted at all). We divide `TurnoverIn` and `TurnoverOut` by 101 days for scaling purposes (so that we can compare our results for the whole dataset to our results for the daily subset). These numbers represent, roughly, an (under)estimate of the number of daily admissions and releases per resident. 

(2) For the daily subset, we look only at Jan 11th to Jan 21st. We do this by taking a subset of `activeDays` that only includes spells whose first day was on or before Jan 21st (so `activeDays$onset <= 87`) AND whose last day was on or after Jan 11th (so `activeDays$terminus > 77`, since `terminus` is the first day on which the spell is gone, i.e., the day after its last day). We consider spells left-censored if they are already there on Jan 11th (so `activeDays_s$onset <= 77`), and we consider spells right-censored if their last day is on or after Jan 21st, meaning that their terminus is on or after Jan 22nd (so `activeDays_s$terminus > 87`). Using this data, we perform the same calculations (counting up admissions and releases, finding the average active network size, and calculating the 11-day turnover rates). We then divide by 11 days for scaling purposes. `TurnoverIn_s` and `TurnoverOut_s` thus give us another estimate of the number of daily admissions and releases per resident, based only on the data from 01/11 to 01/21. 

We perform the above calculations overall and broken down by age, race, and floor. The calculations by age and race are a matter of straightforward subsetting (since age and race are static attributes); the calculations by floor are a little more involved. (For every non-left-censored spell of activity (i.e., admission), we check what floor the resident was in on the first day in that spell. We consider this the floor that they were admitted to. Similarly, for every non-right-censored spell of activity (i.e., release), we check what floor the resident was in on the last day in that spell. We consider this the floor that they were released from. Then we can count up the admissions and releases by floor.)

```{r, child = 'Sections/Step7-JailTurnover.Rmd', echo = FALSE, message = FALSE, warning=FALSE}
```

## Step 8: Create animations of cell-level edges within a single block

In the animations below, blue nodes represent Black residents, green nodes represent white residents, and red nodes represent residents of another race. Larger nodes represent older residents. An edge between two nodes represents two residents being housed in the same cell. A given resident is represented in the animation at time points when they are known (or assumed) to have been in the specified block. 

Again, we take the general approach of assuming that if something is the same in two consecutive rosters, then it was also the same in the time between the two rosters. If an edge is present in one roster and not in the next, then it is assumed to have dissolved immediately after the date of the first roster; similarly, if a resident is in the specified block in one roster but not in the next, then they are assumed to have left immediately after the date of the first roster. For example, if Person A is in Block 1 in Roster 1 (Day 1) and Roster 2 (Day 36) but not in Roster 3 (Day 43), then Person A will be represented in an animation of Block 1 from Day 1 through Day 37 and will not be represented from Day 37 on. 

```{r, child = 'Sections/Step8-Animations.Rmd', echo = FALSE, message = FALSE, warning = FALSE}
```
